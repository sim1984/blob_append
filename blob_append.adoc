= Функция blob_append


*Доступно в*: DSQL, PSQL.

Синтаксис:

`BLOB_APPEND(<blob> [, <value1>, ... <valueN]>`


|===
| Параметр |Описание

|blob
|BLOB или NULL.

|value
|Значение любого типа.
|===


*Тип возвращаемого результата*: временный не закрытый BLOB с флагом
`BLB_close_on_read`.

Флаг `BLB_close_on_read` обозначает что BLOB будет закрыт при попытке чтения его содержимого.

Функция `BLOB_APPEND` предназначена для конкатенации BLOB без создания
промежуточных BLOB. Обычная операция конкатенации с аргументами типа BLOB всегда создаст столько временных BLOB,
сколько раз используется.

Входные аргументы:

* Для первого аргумента в зависимости от его значения определено следующее поведение функции:
- NULL: будет создан новый пустой не закрытый BLOB с флагом
`BLB_close_on_read`
- постоянный BLOB (из таблицы) или временный уже закрытый BLOB:
будет создан новый пустой не закрытый BLOB с флагом `BLB_close_on_read` и содержимое
первого BLOB будет в него добавлено
- временный не закрытый BLOB с флагом `BLB_close_on_read`: он будет использован далее
- другие типы данных преобразуются в строку, будет создан временный не закрытый BLOB с содержимым этой строки

* Для остальных аргументов определено следующее поведение:
- NULL игнорируется
- не BLOB преобразуются в строки (по обычным правилам) и добавляются к содержимому
результата
- BLOB при необходимости транслитерируются к набору символов первого аргумента и их
содержимое добавляется к результату

В качестве выходного значения функция `BLOB_APPEND` возвращает временный не закрытый BLOB с флагом `BLB_close_on_read`.
Это или новый BLOB, или тот же, что был в первом аргументе. Таким образом ряд операций вида
`blob = BLOB_APPEND(blob, ...)` приведёт к созданию не более одного BLOB (если не пытаться добавить BLOB к самому себе).
Этот BLOB будет автоматически закрыт движком при попытке прочитать его клиентом, записать в таблицу или использовать в других выражениях, требующих чтения содержимого.

[NOTE]
.Замечание
====
Проверка BLOB на значение NULL с помощью оператора `IS [NOT] NULL` не читает его, а следовательно временный BLOB
с флагом `BLB_close_on_read` не будет закрыт при таких проверках.
====

[listing,subs=+quotes]
----
execute block
returns (b blob sub_type text)
as
begin
  -- создаст новый временный не закрытый BLOB
  -- и запишет в него строку из 2-ого аргумента
  b = blob_append(null, 'Hello ');
  -- добавляет во временный BLOB две строки не закрывая его
  b = blob_append(b, 'World', '!');
  -- сравнение BLOB со строкой закроет его, ибо для этого надо прочитать BLOB
  if (b = 'Hello World!') then
  begin
  -- ...
  end
  -- создаст временный закрытый BLOB добавив в него строку
  b = b || 'Close';
  suspend;
end
----

[TIP]
.Совет
====
Используйте функции LIST и BLOB_APPEND для конкатенации BLOB. Это позволит сэкономить объём потребляемой памяти, 
дисковый ввод/вывод, а также предотвратит разрастание базы данных из-за создания множества временных BLOB при использовании операторов конкатенации.
====

[example]
.Использование BLOB_APPEND для конкатенации BLOB
====
Предположим вам надо собрать JSON на стороне сервера. У нас есть PSQL пакет JSON_UTILS с набором функций для
преобразования элементарных типов данных в JSON нотацию. Тогда сборка JSON с использованием функции `BLOB_APPEND` будет выглядеть 
следующим образом:

[listing,subs=+quotes]
----
EXECUTE BLOCK
RETURNS (
    JSON_STR BLOB SUB_TYPE TEXT CHARACTER SET UTF8)
AS
  DECLARE JSON_M BLOB SUB_TYPE TEXT CHARACTER SET UTF8;
BEGIN
  FOR
      SELECT
          HORSE.CODE_HORSE,
          HORSE.NAME,
          HORSE.BIRTHDAY
      FROM HORSE
      WHERE HORSE.CODE_DEPARTURE = 15
      FETCH FIRST 1000 ROW ONLY
      AS CURSOR C
  DO
  BEGIN
    SELECT
      LIST(
          '{' ||
          JSON_UTILS.NUMERIC_PAIR('age', MEASURE.AGE) ||
          ',' ||
          JSON_UTILS.NUMERIC_PAIR('height', MEASURE.HEIGHT_HORSE) ||
          ',' ||
          JSON_UTILS.NUMERIC_PAIR('length', MEASURE.LENGTH_HORSE) ||
          ',' ||
          JSON_UTILS.NUMERIC_PAIR('chestaround', MEASURE.CHESTAROUND) ||
          ',' ||
          JSON_UTILS.NUMERIC_PAIR('wristaround', MEASURE.WRISTAROUND) ||
          ',' ||
          JSON_UTILS.NUMERIC_PAIR('weight', MEASURE.WEIGHT_HORSE) ||
          '}'
      ) AS JSON_M
    FROM MEASURE
    WHERE MEASURE.CODE_HORSE = :C.CODE_HORSE
    INTO JSON_M;

    JSON_STR = BLOB_APPEND(
      JSON_STR,
      IIF(JSON_STR IS NULL, '[', ',' || ascii_char(13)),
      '{',
      JSON_UTILS.INTEGER_PAIR('code_horse', C.CODE_HORSE),
      ',',
      JSON_UTILS.STRING_PAIR('name', C.NAME),
      ',',
      JSON_UTILS.TIMESTAMP_PAIR('birthday', C.BIRTHDAY),
      ',',
      JSON_UTILS.STRING_VALUE('measures') || ':[', JSON_M, ']',
      '}'
    );
  END
  JSON_STR = BLOB_APPEND(JSON_STR, ']');
  SUSPEND;
END
----
====

Аналогичный пример с использованием обычного оператора конкатенации || 
работает в 18 раз медленнее (на моём сервере), и делает в 1000 раз больше операций записи на диск.


== О временных BLOB

Временные BLOB - это BLOB-ы, которые сформированы, но пока не записаны (не «присвоены») в обычную таблицу БД.
При создании и даже изменении любого не временного BLOB-объекта всегда сначала создаётся временный BLOB-объект,
который позже будет либо удалён, либо материализован (превращён в обычный) путём записи ссылки на него в
таблицу БД. Содержимое BLOB-ов хранится в БД или во временных файлах (temp_space).

К сожалению создать временный BLOB во временном табличном пространстве, можно только на стороне клиента (или в UDR)
путём присвоения параметру `isc_bpb_storage` значения `isc_bpb_storage_temp` (по умолчанию `isc_bpb_storage_main`, т. е. в БД).
Временные BLOB которые создаются в PSQL всегда располагаются в основном табличном пространстве.
Если бы BLOB создавались сразу во временном пространстве, то при необходимости сохранить этот BLOB в таблицу
БД пришлось бы его заново копировать целиком.
Поэтому из двух зол было выбрано наименьшее, при котором меньше дисковый I/O. Таким образом,
материализация BLOB-а представляет собой простую и быструю операцию без необходимости копирования тела BLOB-а.
Удаление BLOB-а тоже быстрая операция – занятые им страницы просто помечаются как свободные и могут быть повторно
использованы для других BLOB-ов или по другому назначению.

Однако временные BLOB могут быть вовсе не записаны в БД, если их размер менее одной страницы.
Так происходит потому что у открытого BLOB для записи есть свой буфер размером в 1 страницу.
Когда он переполняется, выделяется страница в БД (или в temp_space) и буфер сбрасывается туда.
При закрытии BLOB, буфер сбрасывается в temp file. Когда BLOB материализуется, то есть назначается таблице,
этот остаток пишется в БД (или в temp_space) и место в temp file освобождается.

=== В каких случаях могут создаваться временные BLOB-ы?

* Через API на стороне клиента или в UDR
* При использовании агрегатной функции LIST
* В PSQL при присвоении переменной типа BLOB значения отличного от NULL
* В результате конкатенации BLOB с другими значениями, создаётся новый временный BLOB.
* Некоторые встроенные функции и выражения возвращающие BLOB, если одним из аргументов является BLOB. Например CASE ... END, IIF, COALESCE, REPLACE ... 
* При преобразовании типов к BLOB посредством оператора CAST


Чаще всего временные BLOB образуются конкатенации BLOB со строками или другими BLOB. Причём в результате конкатенации будет создано столько временных BLOB-ов
сколько проведено операций конкатенации. Когда размер временного BLOB превышают одну страницу, то его буфер сбрасывается в БД (поскольку внутри PSQL все временные BLOB создаются в основном табличном пространстве). 
Если таких временных BLOB создаётся много, то это может приводить к разрастанию базы данных. По завершению транзакции страницы отведенные под временные BLOB помечаются свободными и 
могут быть использованы повторно. Однако размер файла БД может значительно увеличиться. Кроме того, создания множество временных BLOB вызывает повышенное потребление памяти, и большое количество операций ввод-вывода (I/O).

=== Как правильно делать конкатенацию BLOB

По возможности лучше избегать конкатенацию BLOB, но если без неё не обойтись, то воспользуйтесь следующими советами уменьшить
негативное влияние от создания множества временных BLOB:

* По возможности используйте агрегатную функцию LIST, там где это возможно. Эта функция создаёт ровно один временный BLOB в результате своей работы. 
* При конкатенации BLOB со строками с помощью оператора || в PSQL используйте промежуточный буфер VARCHAR(N), где N достаточно велик. То есть по возможности накапливайте результаты в строках VARCHAR
большого размера, и лишь затем присоединяйте результат к BLOB. Это поможет уменьшить количество конкатенаций BLOB, а следовательно уменьшит количество временных BLOB.
* Используйте новую функцию BLOB_APPEND, которая позволяет дописывать данные в существующий открытый BLOB. Эта функция при правильном использовании создаёт ровно один временный BLOB.



